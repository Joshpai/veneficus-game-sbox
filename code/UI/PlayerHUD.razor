@using Sandbox;
@using Sandbox.UI;
@inherits PanelComponent

@if (!Movement.LevelStarted)
{
	if (!Health.InRespawn)
	{
		<root>
			<div class="start-hint">
			<div>
				Press
				<img src="@(Input.GetGlyph("use", InputGlyphSize.Small, true).ResourcePath)" />
				to spawn
			</div>
			</div>
		</root>
	}
	return;
}

<root>
	@if (WaveNumber != 0)
	{
		<div class="wave-container">
			<div class="wave-info">
				<div class="wave-data">
					<div>Wave</div>
					<div>@WaveNumber</div>
				</div>
				<div class="wave-data">
					<div>Kills</div>
					<div>@LevelManagerStaticStore.Stats.EnemiesKilled</div>
				</div>
			</div>
		</div>
	}
	<div class="flask health">
		<div class="flask-container">
			<div class="flask-tip"></div>
			<div class="flask-orb">
				<div class="liquid-container">
					<div class="liquid"
						 style="height: @(100.0f * Health.Health / Health.MaxHealth)%;"></div>
					<div class="liquid-overlay radial-gradient"></div>
					<div class="liquid-overlay linear-gradient"></div>
					<!-- <div class="liquid-overlay underlight"></div> -->
				</div>
				<div class="value-container">
					<div class="value">@MathF.Ceiling(Health.Health)</div>
				</div>
			</div>
		</div>
	</div>

	<div class="spells-container">
		<div class="spells">
			@for (int i = (int)BaseSpell.SpellType.SpellTypeMin + 1;
				  i < (int)BaseSpell.SpellType.SpellTypeMax; i++)
			{
				var spellType = (BaseSpell.SpellType)i;

				if (!Spellcasting.IsSpellUnlocked(spellType))
					continue;

				var active = ((int)Spellcasting.ActiveSpell == i)
						   ? "active" : "inactive";
				var spellXpAmount = (100.0f * i) / (float)(BaseSpell.SpellType.SpellTypeMax);
				var xpCol = "black";
				var image = Spellcasting.GetSpellImagePath(spellType);
				var spellName = Spellcasting.GetSpellNiceName(spellType);
				var cooldownCol = "rgba(0, 0, 0, 0.9)";
				//var cooldownAmount = 100.0f - (100.0f * i) / (float)(BaseSpell.SpellType.SpellTypeMax);
				var cooldownAmount = Spellcasting.GetSpellCooldownPercent(spellType);
				// Invert the cooldown (so we rotate counter-clockwise) and scale
				cooldownAmount = 100.0f * (cooldownAmount);
				// Short cooldowns look silly, so just don't render them.
				if (Spellcasting.GetSpellCooldownMax(spellType) < 0.1f)
					cooldownAmount = 0.0f;
				// If the spell is blocked, then show this as a max cooldown
				if (Spellcasting.IsSpellBlocked(spellType))
					cooldownAmount = 100.0f;

				var cost = Spellcasting.GetSpellCost(spellType);

				<!-- Outer circle shows XP, Inner darkened shows cooldown,
					 roman numberal inside shows level. Mana cost? -->
				<!-- TODO: visualise spell charge up time? -->
				<div class="spell @active">
					<div class="xp"
						 style="background-image:
							conic-gradient(@xpCol 0%, @xpCol @spellXpAmount%,
										   transparent @spellXpAmount%)">
						<div class="spell-internal-wrapper">
							<div class="spell-name">
								<p>@spellName</p>
							</div>
							<img src="@image" />
							<!-- <div>Spell Image @i</div> -->
							<!-- <div class="spell-level">III</div> -->
							<div class="cooldown"
								 style="background-image:
									conic-gradient(@cooldownCol 0%,
												   @cooldownCol @cooldownAmount%,
												   transparent @cooldownAmount%)">
							</div>
						</div>
					</div>
				</div>
			}
		</div>
	</div>

	<div class="flask mana">
		<div class="flask-container">
			<div class="flask-tip"></div>
			<div class="flask-orb">
				<div class="liquid-container">
					<div class="liquid"
						 style="height: @(100.0f * Spellcasting.Mana / Spellcasting.MaxMana)%;"></div>
					<div class="liquid-overlay radial-gradient"></div>
					<div class="liquid-overlay linear-gradient"></div>
					<!-- <div class="liquid-overlay underlight"></div> -->
				</div>
				<div class="value-container">
					<div class="value">@MathF.Ceiling(Spellcasting.Mana)</div>
				</div>
			</div>
		</div>
	</div>

	<div class="crosshair-container">
		<div class="crosshair"></div>
	</div>

	<!-- HACK: silly trivial truthy if because @code didn't work -->
	@if (true)
	{
		String animate = "";
		if (Health.Health < _lastHealth)
		{
			_flashHealthTime = FlashHealthTime;
			animate = "animate";
		}
		else if (_flashHealthTime > 0.0f)
		{
			animate = "animate";
		}
		_lastHealth = Health.Health;
		// Log.Info(animate);
		<div class="health-indicator @animate">
		</div>
	}
</root>

@code
{
	[Property]
	public HealthComponent Health { get; set; }

	[Property]
	public PlayerMovementController Movement { get; set; }

	[Property]
	public PlayerSpellcastingController Spellcasting { get; set; }

	[Property]
	public float FlashHealthTime { get; set; } = 0.2f;

	[Property]
	public int WaveNumber { get; set; } = 0;

	private float _lastHealth = 100.0f;
	private float _flashHealthTime = 0.0f;

	protected override void OnFixedUpdate()
	{
		if (_flashHealthTime > 0.0f)
			_flashHealthTime -= Time.Delta;

		if (_flashHealthTime < 0.0f)
			_flashHealthTime = 0.0f;
	}

	/// <summary>
	/// the hash determines if the system should be rebuilt. If it changes, it will be rebuilt
	/// </summary>
	protected override int BuildHash() =>
		System.HashCode.Combine(
			Health.Health,
			Spellcasting.Mana,
			Spellcasting.ActiveSpell,
			Spellcasting.GetSpellCooldown(BaseSpell.SpellType.Fireball) +
			Spellcasting.GetSpellCooldown(BaseSpell.SpellType.Polymorph) +
			Spellcasting.GetSpellCooldown(BaseSpell.SpellType.MagicMissile) +
			Spellcasting.GetSpellCooldown(BaseSpell.SpellType.RendingGale) +
			Spellcasting.GetSpellCooldown(BaseSpell.SpellType.MagicBarrier) +
			Spellcasting.GetSpellCooldown(BaseSpell.SpellType.RockArmour) +
			Spellcasting.GetSpellCooldown(BaseSpell.SpellType.LightningStrike) +
			Spellcasting.GetSpellCooldown(BaseSpell.SpellType.WaterBeam),
			SaveData.Instance.Data.UnlockedSpells,
			Movement.LevelStarted,
			Health.InRespawn,
			(_flashHealthTime != 0.0f)
		);
}
